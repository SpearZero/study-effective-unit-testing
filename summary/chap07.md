## 7장

### 테스트 가능 설계란?
- 테스트 가능 설계의 가장 큰 의의는 코드를 더 잘 테스트할 수 있도록 해준다는 것이다.
- 테스트 가능 설계는 테스트 코드에서 클래스를 생성하고, 구현 일부를 대체하고, 다른 시나리오를 시뮬레이션 하고,
원하는 겨실행 경로를 선택하는 등의 작업을 쉽게 할 수 있도록 해준다.
- 테스트 용이성(testability)이란 소프트웨어를 <b>얼마나 쉽게</b> 테스트할 수 있느냐를 평가하는 용어다.

#### 모듈러 설계
- 제품은 특정 역할을 담당하는 독립 모듈로 구성된다는 그 본질만 잘 반영하면 자연스럽게 모듈러 설계가 만들어진다.
- 모듈 간 연결 인터페이스는 유연성을 높여주는 원천이다.
- 모듈러 설계는 자연스럽게 테스트하기 좋은 코드를 만들어준다.

#### SOLID 설계 원칙
- 단일 책임 원칙(SRP, Single Responsibility Principle)
  - 클래스를 수정해야 하는 이유는 오직 하나뿐이어야 한다.
  - 클래스는 작고 한 가지 역할에만 충실하고 응집력이 높아야 한다.
- 개방 폐쇄 원칙(OCP, Open-Closed Principle)
  - 클래스는 확장을 위해서는 개방적이되 수정에 대해서는 폐쇄적이어야 한다.
  - 코드 수정 없이도 클래스의 기능을 변경할 수 있도록 하자
    - ex) 전략 패턴(strategy pattern)
- 리스코프 치환 원칙(LSP, Liskov Substitution Principle)
  - 상위 클래스는 하위 클래스로 대체될 수 있어야 한다.
    - 리스코프 치환 원칙을 지키면 정당한 근거로 만들어진 클래스 계층 구조만 남게 된다. 즉, 코드 재사용을 편하게 할 요량으로 만들어진 계층 구조는 사라진다.
  - LSP를 잘 지키면 <b>계약 테스트</b>(Contract Test)가 가능하여 테스트 용이성이 높아진다.
    - 계약 테스트란 인터페이스에 정의된 기능을 제공하겠다는 계약을 그 구현체가 제대로 지키는지 검증하는것을 말한다.
- 인터페이스 분리 원칙(ISP, Interface Segregation Principle)
  - 하나의 범용 인터페이스보다 쓰임새별로 최적화한 인터페이스 여러 개가 낫다.
  - 인터페이스는 작고 한 가지 목적에 충실하도록 만들어야 한다.
- 의존 관계 역전 원칙(DIP, Dependency Inversion Principle)
  - 코드는 구현체가 아닌 추상 개념에 종속되어야 한다.
  - 극단적으로 보면, 의존 관계 역전 원칙에 따르면 클래스는 협력 객체를 직접 생성하지 말고 인터페이스로 건네받아야 한다.
  - <b>종속 객체 주입</b> 방식을 적용하면 협력 객체를 마음대로 교체할 수 있다.

#### 맥락을 고려한 모듈러 설계
팀 버너스리 

> 모듈을 조합하여 시스템을 구성할 수 있게 하는 것은 물론 중요하다. 하지만 당장은 그 시스템이 아무리 크고 멋있어 보이더라도 언젠가 더 큰 시스템의 일부로 될 수 있도록 설계해야 한다.

#### 모듈러 설계를 위한 시운전
제품 코드보다 테스트를 먼저 작성하게 되면 확실히 API의 사용자인 고객의 관점에서 바라보게 된다. 이는 목적에 잘 들어맞게끔 설계할 가능성이 높아진다는 뜻이다.

TDD를 하게되면 수시로 리팩토링 하기 때문에 작게 나눠야 할 큰 메서드나 더 적절한 추상화 수준, 제거할 중복 등을 끊임없이 찾아낸다.

### 테스트 불가 원인
- 원하는 것에 접근하지 못함
- 대상 코드의 특정 부분을 마음대로 교체 할 수 없음

#### 클래스 생성 불가
- 접근 제한자(visibility modifier)를 보수적으로 설정
- 정적 초기화 블록을 잘못 사용

#### 메서드 호출 불가
- private 메서드 호출
- 어떤 인자를 넣어야 할지 알쏭달쏭한 경우
  - ex) java.util.Map의 경우 무엇을 담아야 할지가 직관적이지 않아서 소스코드나 문서를 찾아보느라 개발 흐름이 끊기게 한다.

#### 결과 확인 불가
- 메서드를 호출했지만 결과가 올바른지 확인할 수 없는 경우
  - ex) void 메서드 또는 다른 협력 객체와 상호작용하는 메서드
- 확인해야 할 상호작용을 가로챌 방법이 없을 때
  - 협력 객체가 테스트할 메서드 안에 묶여 있어서 테스트 더블로 대체하지 못하는 경우

#### 협력 객체 대체 불가
- 협력 객체를 대체하지 못하는 상황
  - 상호작용이 잘 이루어졌는지 확인해야 하는데, 그 객체를 생성하는 로직이 제품 코드에 하드코딩 되어 있는 경우
- 협력 객체를 대체할 수 있지만, 그 과정이 복잡한 경우
  - <b>메서드 연쇄 호출</b>(method chain)의 경우
  - 테스트 더블을 반환하는 테스트 더블을 반환하는 ... 테스트 더블을 만들어야 한다.

#### 메서드 오버라이딩 불가
- 협력 객체의 전부를 대체하기 보다 <b>대상 객체의 일부 코드</b>만 변경하고 싶은 경우
  - private static final Collaborator getCllaborator() { ... } 같은 경우 final, private, static 키워드로 인해 메서드 오버라이딩을 하지 못한다.

### 테스트 가능 설계를 위한 지침

#### 복잡한 private 메서드를 피하라
애초에 private 메서드는 직접 테스트할 필요가 없도록 만들어야 한다.

private 메서드의 용도를 public 메서드의 가독성을 높이기 위한 간단한 유틸리티로 제한한다면 public 메서드만 테스트해도 private 메서드까지 확실하게 검증된다.

#### final 메서드를 피하라
final 선언으로 얻는 이득이 테스트 용이성보다 큰 경우에 사용해야 한다.

#### 정적 메서드를 피하라
단위 테스트에서 언젠가 스텁으로 바꿔야 할듯한 메서드는 정적 메서드로 만들지 않는다.
- 순수 계산 작업을 스텁으로 만들일이 거의 없다.
- 서비스나 협력 객체를 얻고자 만들었던 정적 메서드는 스텁으로 교체하고 싶은 경우가 많음

정적 메서드는 만들기는 쉽지만, 나중에 테스트에서 스텁으로 교체하고 싶을 경우엔 속을 썩인다.

#### new는 신중하게 사용하라.
메서드 본문에서 new 키워드를 사용하면 테스트 더블로 대체할 가능성이 없다.

바이트코드를 조작하지 않고는 대상 코드가 특정 클래스를 새성하는 걸 테스트에서 저지할 방법이 없다.

#### 생성자에서는 로직 구현을 피하라
하위 클래스는 상위 클래스 중 하나를 호출 할 수 밖에 없다. 따라서 테스트에 영향을 미칠만한 로직은 생성자에 넣어서는 안된다.

생성자에는 단위 테스트에서 교체해야 할만한 코드는 절대 넣어서는 안 된다. 만약 이런코드를 발견하면 일반 메서드로 추출하거나 외부에서 객체 형태로
입력받게끔 수정하여 테스트에서 원하는 대로 바꿔칠 수 있도록 해야한다.

#### 싱글톤을 피하라
싱글톤 
- <b>클래스의 인스턴스가 단 하나만 만들어진다는 것을 보장하고, 어디에서나 접근할 수 있도록 한</b> 패턴

싱글톤 객체는 한 번 초기화되면 절대로 교체할 수 없다.
- 정적 메서드를 사용하기 때문에 다른 객체로 변경하고 싶다면 리플렉션 API를 사용하거나, setter 메서드를 마련해야 한다.

꼭 정적 싱글톤 메서드를 사용해야겠다면 getInstance() 메서드가 클래스가 아닌 인터페이스를 반환할 것을 추천한다.
- 테스트에서 원하는 대로 조작하기 수월하다.

#### 상속보다는 컴포지션을 사용하라
상속으로 코드를 재사용할 수 있는건 맞지만, 그렇게 만들어진 클래스 계층 구조는 변경할 수 없으므로 테스트 용이성을 떨어뜨린다.

상속의 용도는 다형성이지 코드 재사용이 아니다.

상속은 컴파일 시에 모든 미래가 결정된다.(상위 클래스의 생성자에 묶이고, 상위 클래스 API가 변경되면 따라야 함)

컴포지션은 실행 도중 마음껏 교체할 수 있다.

<b>기능을 재활용</b>하기 위한 목적이라면 상속보다는 컴포지션 방식이 낫다.

#### 외부 라이브러리를 감싸라
코드에 대한 제어권이 없기 때문에 테스트의 용이성이 떨어진다. 직접 다른 구현으로 교체하기 쉽고 테스트하기도 편한
인터페이스를 하나 만들어서 그 라이브러리를 감싸버리자.

#### 서비스 호출을 피하라
서비스 호출보다는 생성자에 종속 객체를 직접 전달하자.

서비스 호출 단점
- 테스트 용이성을 제공하지 못함
- 생성자의 입력 인자를 통해 드러났어야 할 종속성이 클래스 속으로 숨어버린다.