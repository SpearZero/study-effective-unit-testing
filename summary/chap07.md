## 7장

### 테스트 가능 설계란?
- 테스트 가능 설계의 가장 큰 의의는 코드를 더 잘 테스트할 수 있도록 해준다는 것이다.
- 테스트 가능 설계는 테스트 코드에서 클래스를 생성하고, 구현 일부를 대체하고, 다른 시나리오를 시뮬레이션 하고,
원하는 겨실행 경로를 선택하는 등의 작업을 쉽게 할 수 있도록 해준다.
- 테스트 용이성(testability)이란 소프트웨어를 <b>얼마나 쉽게</b> 테스트할 수 있느냐를 평가하는 용어다.

#### 모듈러 설계
- 제품은 특정 역할을 담당하는 독립 모듈로 구성된다는 그 본질만 잘 반영하면 자연스럽게 모듈러 설계가 만들어진다.
- 모듈 간 연결 인터페이스는 유연성을 높여주는 원천이다.
- 모듈러 설계는 자연스럽게 테스트하기 좋은 코드를 만들어준다.

#### SOLID 설계 원칙
- 단일 책임 원칙(SRP, Single Responsibility Principle)
  - 클래스를 수정해야 하는 이유는 오직 하나뿐이어야 한다.
  - 클래스는 작고 한 가지 역할에만 충실하고 응집력이 높아야 한다.
- 개방 폐쇄 원칙(OCP, Open-Closed Principle)
  - 클래스는 확장을 위해서는 개방적이되 수정에 대해서는 폐쇄적이어야 한다.
  - 코드 수정 없이도 클래스의 기능을 변경할 수 있도록 하자
    - ex) 전략 패턴(strategy pattern)
- 리스코프 치환 원칙(LSP, Liskov Substitution Principle)
  - 상위 클래스는 하위 클래스로 대체될 수 있어야 한다.
    - 리스코프 치환 원칙을 지키면 정당한 근거로 만들어진 클래스 계층 구조만 남게 된다. 즉, 코드 재사용을 편하게 할 요량으로 만들어진 계층 구조는 사라진다.
  - LSP를 잘 지키면 <b>계약 테스트</b>(Contract Test)가 가능하여 테스트 용이성이 높아진다.
    - 계약 테스트란 인터페이스에 정의된 기능을 제공하겠다는 계약을 그 구현체가 제대로 지키는지 검증하는것을 말한다.
- 인터페이스 분리 원칙(ISP, Interface Segregation Principle)
  - 하나의 범용 인터페이스보다 쓰임새별로 최적화한 인터페이스 여러 개가 낫다.
  - 인터페이스는 작고 한 가지 목적에 충실하도록 만들어야 한다.
- 의존 관계 역전 원칙(DIP, Dependency Inversion Principle)
  - 코드는 구현체가 아닌 추상 개념에 종속되어야 한다.
  - 극단적으로 보면, 의존 관계 역전 원칙에 따르면 클래스는 협력 객체를 직접 생성하지 말고 인터페이스로 건네받아야 한다.
  - <b>종속 객체 주입</b> 방식을 적용하면 협력 객체를 마음대로 교체할 수 있다.

#### 맥락을 고려한 모듈러 설계
팀 버너스리 

> 모듈을 조합하여 시스템을 구헝할 수 있게 하는 것은 물론 중요하다. 하지만 당장은 그 시스템이 아무리 크고 멋있어 보이더라도 언젠가 더 큰 시스템의 일부로 될 수 있도록 설계해야 한다.

#### 모듈러 설계를 위한 시운전
제품 코드보다 테스트를 먼저 작성하게 되면 확실히 API의 사용자인 고객의 관점에서 바라보게 된다. 이는 목적에 잘 들어맞게끔 설계할 가능성이 높아진다는 뜻이다.

TDD를 하게되면 수시로 리팩토링 하기 때문에 작게 나눠야 할 큰 메서드나 더 적절한 추상화 수준, 제거할 중복 등을 끊임없이 찾아낸다.

### 테스트 불가 원인
- 원하는 것에 접근하지 못함
- 대상 코드의 특정 부분을 마음대로 교체 할 수 없음

#### 클래스 생성 불가
- 접근 제한자(visibility modifier)를 보수적으로 설정
- 정적 초기화 블록을 잘못 사용

#### 메서드 호출 불가
- private 메서드 호출
- 어떤 인자를 넣어야 할지 알쏭달쏭한 경우
  - ex) java.util.Map의 경우 무엇을 담아야 할지가 직관적이지 않아서 소스코드나 문서를 찾아보느라 개발 흐름이 끊기게 한다.

#### 결과 확인 불가
- 메서드를 호출했지만 결과가 올바른지 확인할 수 없는 경우
  - ex) void 메서드 또는 다른 협력 객체와 상호작용하는 메서드
- 확인해야 할 상호작용을 가로챌 방법이 없을 때
  - 협력 객체가 테스트할 메서드 안에 묶여 있어서 테스트 더블로 대체하지 못하는 경우

#### 협력 객체 대체 불가
- 협력 객체를 대체하지 못하는 상황
  - 상호작용이 잘 이루어졌는지 확인해야 하는데, 그 객체를 생성하는 로직이 제품 코드에 하드코딩 되어 있는 경우
- 협력 객체를 대체할 수 있지만, 그 과정이 복잡한 경우
  - <b>메서드 연쇄 호출</b>(method chain)의 경우
  - 테스트 더블을 반환하는 테스트 더블을 반환하는 ... 테스트 더블을 만들어야 한다.

#### 메서드 오버라이딩 불가
- 협력 객체의 전부를 대체하기 보다 <b>대상 객체의 일부 코드</b>만 변경하고 싶은 경우
  - private static final Collaborator getCllaborator() { ... } 같은 경우 final, private, static 키워드로 인해 메서드 오버라이딩을 하지 못한다.

