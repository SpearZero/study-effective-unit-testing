## 4장

- 테스트를 읽은 프로그래머는 코드가 <b>해야 할 일</b>을 이해할 수 있어야 한다.
- 테스트를 실행한 후에는 코드가 실제로 <b>한 일</b>이 무엇인지 말할 수 있어야 한다.
- 테스트의 핵심인 단언문은 대상 코드의 올바른 동작을 규정한다
  - 테스트의 성패를 판별하는 것은 단언문이다.
  - 단언문을 제대로 작성하지 않으면 테스트의 의도를 파악하기 힘들다.

### 기본 타입 단언
기본 타입 단언(Primitive Assertions)이란 단언하려는 이유나 의도가 의미를 알 수 없는 단어나 숫자에 가려진 상황을 말한다.

#### 예시
그렙(grep) 유틸리티를 테스트하는 코드

```java
@Test
public void outputHasLineNumbers(){
    ...
    // 단언문을 이해하려면 불필요한 두뇌 활동이 필요하다.
    // 추상화 수준이 낮다.
    assertTrue(out.indexOf("test.txt:1 1st match") != -1)
}
```

```java
// 인덱스나 매직 넘버인 -1를 사용하는 건 개념을 잘못 추상화한 예다.
asssertThat(out.indexOf("test.txt:1 1st match"), is(not(-1)));
```

```java
// indexOf에서 추상화 수준을 한 단계 높인 contains 사용
assertTrue(out.contains("test.txt:1 1st match"));
```

```java
// assertThat과 contains 사용
assertThat(out.contains("test.txt:1 1st match"), equals(true));
```

```java
// 햄크레스트 매처 사용
assertThat(out, containsString("test.txt:1 1st match"));
```

취향에 맞는 방향을 택해서 단언을 하면 된다. 단, 검사하려는 기능과 단언문을 같은 언어와 어휘로 표현해야 한다.

#### 정리
텍스트에서 !=나 == 등의 비교문을 사용하는 단언문을 발견하면 추상화 수준이 적절한지 되짚어보라.

단언문을 즉시 이해할 수 없다면 기본 타입 단언에 해당하며 리팩토링 대상이 될 가능성이 높다.

### 광역 단언
광역 단언(Hyperassertion)은 범위가 넓어서 어느 하나만 잘못되어 바로 실패하게 되고, 본래 의도했던 것도 그 광활한 검증 범위에 묻혀 희석된다.

#### 개선 방법
- 본질과 관련 없는 세부 내용을 찾아 테스트에서 제거한다.
  - 책의 예시) 테스트를 위한 로그 내용의 라인 수를 줄인다. 테스트 목적을 이룰 수 있는 만큼의 정보만 있으면 된다.
- 테스트를 나눠라
  - 세분화된 주제에 충실한 테스트면 실패했을 때 문제의 근본 원인을 빠르게 찾을 수 있다.

#### 정리
광역 단언은 대상을 너무 크게 묶어서 모든걸 비교하려다 보니 너무 쉽게 망가져 버린다.

광역 단언은 프로그래머가 테스트의 의도와 핵심을 파악하는 데도 방해된다.(범위가 커서 테스트 코드를 분석해야 함)

### 비트 단언
비트 단언(Bitwise Assertion)은 기본 타입 단언의 특수한 형태다.

추상화 수준이 너무 낮아서 테스트 의도나 의미를 파악하기 어렵다.

#### 개선 방법
비트 연산자를 부울 연산자(Boolean operation)로 교체해서 기대하는 결과를 하나씩 명확하게 표현하면 된다.

#### 정리
간단히 표현하기 위한 수단으로 비트 연산을 사용한다면 어려운 코드를 만들게 된다. 
비트 연산자는 비트 연산자로 남겨두고, 고수준 개념은 그에 합당한 고차원적인 언어로 표현하는게 옳다.

### 부차적 상세정보
테스트 코드에 본질적인 부분이 아닌 부수적인 정보가 넘쳐 흐를 때가 종종 있는데, 이를 <b>부차적 상세정보</b>(Incidental Details)냄새라 한다.

#### 개선 방법
- 핵심이 아닌 설정은 private 메서드나 셋업 메서드로 추출하라
- 적절한 인자와 서술형 이름을 사용하라.
- 한 메서드 안에서는 모두 같은 수준으로 추상화하라.

#### 정리
핵심이 아닌 코드나 정보를 도우미 메서드나 셋업 메서드로 내몰아야한다. 특히 '한 메서드 안에서는 모두 같은 수준으로 추상화하라'라는 말을 항시 기억해두면 좋다.

### 다중 인격
<b>다중 인격</b>(Split Personality)이란 여러 개의 테스트 목적이 테스트 메서드를 공유하는 걸 말한다.

하나의 테스트는 오직 한 가지만 똑바로 검사해야한다.(한 가지를 검사하는데도 단언문은 여러개 사용될 수 있음)

#### 개선 방법
중복을 제거한다.

하나의 테스트에 있는 서로 다른 목적의 테스트를 각각의 테스트로 분리한다.

#### 정리
테스트의 여러 관심사를 각자의 클래스로 분리하면 뒤섞였던 테스트의 의미가 드러나 이해하기 쉬워진다.

### 쪼개진 논리
여러 곳으로 흩어진 코드를 분석하게되면 프로그래머의 인지능력에 과부하가 걸린다.

흩어진 정보는 프로그래머의 인지 부하를 가중시키고, 테스트의 의미와 의도를 파악하기 어렵게 한다.

#### 개선 방법
필요한 외부 데이터와 코드를 모두 테스트 안으로 이주시키면 된다.

데이터나 로직을 통합해야 할 떄
- 짧다면 통합해라
- 통합하기에 너무 길다면 팩토리 메서드나 테스트 데이터 생성기를 통해 만들어라
- 이마저도 쉽지 않다면 그냥 독립 파일로 남겨둬라

데이터를 독립 파일로 나누는건 좋지 않지만, 어쩔 수 없이 나눠야 한다면 다음 지침을 따르는게 좋다.
- 시나리오에 꼭 필요한 최소한의 데이터만 남긴다.
- 데이터 파일과 이를 사용하는 테스트와 같은 폴더에 둔다.
  - 데이터 파일을 찾기 쉽고 테스트 코드를 다른 곳으로 옮길 때 빼먹지 않을 수 있다.
- 이런 구조를 취하게 되면 팀 공통의 규약을 만들고 따라야 한다.

#### 정리
쪼개진 논리 냄새는 테스트의 논리나 데이터가 필요 이상으로 여러 곳으로, 특히 여러 파일로 분리되어 있다는 경고다.

### 매직 넘버
<b>매직 넘버</b>(magic number)를 피해야한다. 매직 넘버란 소스코드 중 할당문이나 메서드 호출 등에 박혀 있는 숫자로 된 값을 말한다.

매직 넘버를 처리하는 전통적인 조언은 '의미가 분명한 이름의 상수나 변수로 대체해서 읽기 쉬운 코드라 만들라'라는 것이 있다.

#### 개선 방법
매직 넘버에 이름을 부여하고 의미와 관계를 명시하거나 정적 상수나 지역 변수로 바꿔주면 된다.

#### 정리
매직 넘버는 코드 한가운데 떡하니 자리를 잡고서 아무것도 말해주지 않는 숫자다. 

지역 변수나 서술형 이름의 상수로 대체하는 게 매직 넘버를 없애고 의미 전달력을 키워주는 가장 보편적인 방법이다.

### 셋업 설교
셋업 설교(setup sermon)는 짧은 테스트를 위한 너무 긴 준비작업(셋업)을 뜻한다.

픽스처(fixture)
- 테스트가 실행하는 <b>어떤 것</b>
  - 시스템 속성, 테스트 클래스에 정의된 상수, 셋업 메서드가 초기화한 private 멤버 등

테스트를 온전히 이해하려면 텍스트가 사용하는 픽스처도 이해해야 한다. 

셋업의 역할은 테스트를 실행하기 위한 상태와 필요한 객체를 미리 만들어 놓는것이다 보니 픽스처 정의 대부분을 셋업에서 처리하게 된다.

#### 개선 방법
- 셋업에서 핵심을 제외한 상세 정보는 private 메서드로 추출한다.
- 알맞은 서술적 이름을 사용한다.
- 셋업 내의 추상화 수준을 통일한다.

#### 정리
셋업은 픽스처의 주요 부분을 구성하고 테스트가 실행될 환경을 조성한다. 

픽스처를 이해하지 못하면 테스트의 목적을 온전히 이해할 수 없다. 따라서 셋업 설교도 테스트 메서드의 부차적 상세정보를 다룰 때와 같은 마음가짐으로 대처해야 한다.

### 과잉보호 테스트
과잉보호 테스트(overprotective tests)는 테스트의 성패를 결정짓는 진짜배기 단언문에 도달하기 전까지 불필요한 중간 단계 단언문이 많이 등장하는 것을 말한다.

#### 개선 방법
불필요한 단언문을 지워버리면 된다.

#### 정리
불필요한 단언문은 아무런 가치도 보태주지 않으므로 제거되어야 마땅하다. 테스트는 어짜피 실패하기 때문이다.(assert문에서 실패가 검증된다.)
