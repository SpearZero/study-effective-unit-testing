## 3장

테스트 대상 코드를 격리하고, 속도를 개선하고, 예측 불가능한 요소를 제어하고, 특수한 상황을 시뮬레이션 하고, 감춰진 정보를 얻어내는 용도로 쓰이는 이러한 다양한 객체들을 <b>테스트 터블</b>이라고 한다.

### 테스트 더블의 위력

테스트하려는 코드를 주변에서 분리하는 것이 테스트 더블을 활용하는 가장 기본적인 이유다.

테스트 전용 장치가 필요한 이유
- 테스트 대상 코드를 격리한다.
- 테스트 속도를 개선한다.
- 예측 불가능한 실행 요소를 제거한다.
- 특수한 상황을 시뮬레이션 한다.
- 감춰진 정보를 얻어낸다.

#### 테스트 대상 코드를 격리한다
테스트하려는 코드를 그 외의 모든 코드에서 떼어놓으면, 테스트는 초점이 분명해지고, 이해하기도 쉬워지고, 설정하기도 간편해진다.

#### 테스트 속도를 개선한다
테스트의 협력 객체에서 수행하는 작업이 오래 걸리면 개발자는 즉각적인 피드백을 기대할 수 없다. 테스트 더블을 이용해서 사전에 계산해둔 값을 반환하면 쓸데없이 기다리는 시간이 줄어들어 테스트가 빨라진다.

#### 예측 불가능한 실행 요소를 제거한다
테스트란 동작을 정의하고 명세와 일치하는지 확인하는 작업이다. 대상 코드가 완벽히 결정적이라서 불확정 요소가 전혀 없다면 꽤 간단하고 명확한 일일 것이다. 테스트 더블을 이용하여 예측할 수 없는 요인을 다룰 수 있다.

#### 특수한 상황을 시뮬레이션 할 수 있다
테스트 더블을 이용하여 특수한 상황을 발생 시킬 수 있다.
- ex) 자동차 경로 검색 중 인터넷이 끊기는 상황을 테스트 하기

#### 감춰진 정보를 얻어낸다
테스트가 얻을 수 없었던 정보에 접근할 수 있다. 
- ex) JAVA의 private 변수에 값이 제대로 할당되었는지 확인

### 테스트 더블의 종류
- 테스트 스텁
- 가짜 객체
- 테스트 스파이
- Mock 객체

#### 테스트 스텁은 유난히 짧다
원래의 구현을 최대한 단순한 것으로 대체하는 것이다. 가장 간단한 예라면 기본값을 반환하는 한 줄짜리 메서드로 가득 찬 클래스가 있다.

```java
public class LoggerStub implements Logger {
    public void log(LogLevel level, String message) {
        // 아무일도 하지 않음
    }
    
    public LogLevel getLogLevel() {
        return LogLevel.WARN;   // 하드코딩된 값 반환
    }
}
```

#### 가짜 객체는 뒤끝 없이 처리한다
가짜 객체는 진짜 객체의 행동을 흉내 내지만, 진짜 객체를 사용할 때 생기는 부수 효과나 연쇄 동작이 일어나지 않도록 경량화하고 최적화 한 것이다.

```java
public interface UserRepository {
    void save(User user);
    User findById(long id);
    User findByUsername(String username);
}
```
```java
public class FakeUserRepository implements UserRepository {
    private Collection<User> users = new ArrayList<User>();
    
    public void save(User user) {
        // 초간단 인메모리 데이터베이스를 구현
        ...
    }

    public User findById(long id) {
        ...
    }

    public User findByUsername(String username) {
        ...
    }
}
```

#### 테스트 스파이는 기밀을 훔친다
입력 인자로 사용되는 개체가 테스트에 필요한 정보를 알려주는 API를 제공하지 않을 때 유용하다.

테스트 스파이는 목격한 일을 기록해두었다가 나중에 테스트가 확인할 수 있게끔 만들어진 테스트 더블이다.

#### Mock 객체는 예기치 않은 일을 막아준다
특수한 형태의 테스트 스파이다. 특정 조건이 발생하면 미리 약속된 행동을 취한다.

### 테스트 더블 활용 지침

#### 용도에 맞는 더블을 선택하라

- 두 객체 간 상호작용의 결과로 특정 메서드가 호출되었는지 확인하고 싶다면 Mock 객체를 써야 할 가능성이 높다.
- Mock 객체를 사용하기로 했는데, 테스트 코드가 생각만큼 깔끔하게 정리되지 않는다면 더 단순한 테스트 스파이를 손수 작성해서도 똑같은 마술을 부릴 수 있는지 생각해보자.
- 협력 객체는 자리만 지키면 되고 협력 객체가 대상 객체에 넘겨줄 응답도 테스트에서 통제할 수 있다면 스텁이 정답이다.
- 필요한 서비스나 컴포넌트를 미처 준비하지 못해 스텁을 대용품으로 사용하고 있는데, 시나리오가 너무 복잡해서 벽에 부딪혔거나 테스트 코드가 관리하기 어려울 만큼 복잡해졌다면 가짜 객체를 구현하는 걸 고려해보자.

#### 준비하고, 시작하고, 단언하라

단위 테스트 구조에 관한 규약
- 준비-시작-단언(AAA, arrange-act-assert)
  - 필요한 객체들을 준비하고, 실행하고, 결과를 단언하는 세 단계로 테스트 구성
- GIVEN, WHEN, THEN
  - '행위 주도 개발' 진영에도 AAA와 유사한 용어와 구조가 사용됨
  - 주어진 상황(Given)에서, 어떤 일이 발생했을 때(When), 특정 결과를 기대한다.(Then)

위의 구조들은 광범위하게 쓰이며 테스트가 산만해지지 않게 지탱해준다. 세 영역 중 하나가 비대하다고 느껴진다면, 너무 많은 것을 한꺼번에 검사하려는 테스트일 가능성이 높다. 더 작은 단위의 기능을 집중적으로 검사하는 테스트로 나눌 필요가 있다는 신호다.

#### 구현이 아니라 동작을 확인하라
테스트는 오직 한 가지만 검사해야 하고 그 의도를 명확히 전달하도록 작성되어야 한다.
- 굳이 확인할 필요 없는 부수적인 것은 구현하지 않아도 된다.

Mock에는 정말 바라고 의도한 핵심 동작만 설정하면 된다.

#### 자신의 도구를 선택하라
자신에게 필요한 Mock 객체 라이브러리를 선택하면 된다.

#### 종속 객체를 주입하라
종속 객체를 다른 객체로 교체해야만 쉽게 검사할 수 있다면 그 객체를 사용하는 곳과 생성하는 곳을 달리 하는것이 좋다.

종속 객체를 private 필드에 저장하거나 팩토리 메서드 등을 통해 외부로부터 얻도록 해야 한다.
- 접근 제한자를 수정하거나 리플렉션 API를 사용하는것보다 <b>종속 객체 주입법</b>을 사용하는 법이 좋다.
- 주로 <b>생성자 주입</b> 방식을 많이 사용