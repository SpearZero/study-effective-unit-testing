## 5장
코드는 쓰이는 횟수보다 읽히는 횟수가 많다.

현실에서의 코드<b>작성</b>의 대부분은 기존 코드를 수정하거나 확장하는 걸 뜻한다.
- 코드 어딘가를 고쳐야 한다는 사실은 변함이 없다.

코드는 유연한 동시에 망가지기도 쉽다.
- 테스트 코드도 코드이기 때문에 불안정하다.

5장에서도 테스트 냄새와 해결책을 제시

### 중복
중복은 <b>필요 없는 반복</b>이다.

중복의 예시
- 코드베이스 전반에 걸쳐 반복되는 특정 숫자값과 문자열
- 곳곳에 흩뿌려진 하드코딩된 데이터 값
- 역할이 겹치는 두 클래스나 객체 또는 메서드
- 모양은 다르지만 기능이 같은 코드조각

중복은 개념과 논리를 흩어놓아서 코드를 이해하기 어렵게 만들며, 코드가 수정되면 중복된 곳도 손봐야 한다.

#### 개선 방법
중복된 문자열을 제거하고 구조의 중복을 개선한다.

#### 정리
중복을 제거를 하되 과유불급이 되지 않게 제거하라, 최우선 목표는 코드를 읽기 쉽게 유지하여 읽는 이에게 그 의도와 기능을 명확히 전달하는 것이다.

### 조건부 로직
조건부 로직(Conditional logic)을 포함하는 테스트는 코드가 하는 일 혹은 해야 할 일을 파악할 때 제 역할을 못할 가능성이 높다.

#### 개선 방법
복잡한 코드를 다룰 때는 간소화부터 시도하는 게 좋다.(ex, 코드 블록을 적절한 이름의 메서드로 추출)

#### 정리
코드를 수정하려면 이해를 해야 하는데 조건부 로직이 들어 있으면 코드파악이 훨씬 어려워진다.

조건부 로직은 일부 단언문 혹은 전체를 송두리째 건너 뛰는 경우도 있다.

테스트 메서드는 if, else, for, while, switch 같은 조건부 실행 구조를 가져서는 안된다.

### 양치기 테스트
양치기 테스트(Flaky test)는 간헐적으로 실패하는 테스트다. 이런 테스트는 테스트가 실패해서 빌드가 중단되었는데, 막상 다시 돌려보면, 때마침 운이좋아 보란듯이 통과해버린다.

#### 개선 방법
시간 관련일 경우 많은 개발자가 Thread#sleep을 사용하지만 비결정적이며, 테스트가 느려지게 된다.

테스트 도중 시간 관련 문제가 생기면 원하는 상황을 시뮬레이션 할 수 있는 API가 있는지 살펴보자.

멀티스레딩이나 난수 발생기의 경우도 골치아픈 상황을 만들 수 있다. 이러한 상황을 벗어나기 위해 다음과 같은 방법이 있다.

1. 회피한다.
    - 비결정적인 원흉을 제거
2. 제어한다.
   - 값을 원하는 순서로 반환하도록 가짜 객체 사용
3. 격리한다.
    - 골칫거리를 코드베이스에서 가능한 좁은 구석으로 격리

#### 정리
시스템 시계, 테스트를 돌리는 시각, 공유 자원에 동시 접근, 난수 발생기 등 불규칙한 실패의 원인이 발생하면
회피하거나 제어하거나 격리하면 된다.

### 파손된 파일 경로
파손된 파일 경로(Cripping File Path)는 파일 경로가 특정 개발자 컴퓨터 외에는 그 어디에서도 돌아가지 못하게 한다.
(ex, 특정 운영체제 종속적인 절대 경로 하드코딩)

#### 개선 방법
절대 경로는 피해야 한다. 가능하다면 반드시 상대 경로를 쓰고, 정 안되면 시스템 속성이나 환경 변수로 한 단계 더 추상화하여 접근하라

파일을 스트림으로 대체하면 테스트 더블로 교체할 수도 있다.(스트림은 인터페이스기 때문)

특정 테스트 클래스에서만 사용하거나 같은 패키지 안의 테스트 클래스들에서만 사용하는 파일이라면 자바의 클래스패스로 파일에 접근하는 것이 좋다.

#### 정리
절대 경로는 모든 개발자에게 그 특정 경로를 사용하도록 강제한다.

프로젝트에 필요한 모든 자원은 프로젝트 루트 디렉터리의 하위에 두는 걸 원칙으로 하라.

### 끈질긴 임시 파일
끈질긴 임시 파일(Persistent temp files)테스트란 다음번 테스트 수행 시까지도 지워지지 않고 버티고 있는 상황을 말한다.

#### 개선 방법
파일 사용은 무조건 최소한으로 자제해야 한다.(파일 I/O 사용시 테스트가 느려진다.)

임시 파일에 대처하는 간단한 지침
- @Before 메서드에서 파일을 삭제하라.
- 가능하면 임시 파일명도 고유하게 지어라.
- 파일이 있어야 하는지를 명시하라.

#### 정리
파일을 다루는 테스트는 테스트끼리 방해하는 상황을 만들 수 있다. 이 문제를 피해가거나 최소화 하기 위해서는
임시 파일에 대처하는 지침을 지켜야 한다.

### 잠자는 달팽이
기대하는 결과나 부수효과를 얻기 위해 다른 스레드가 일을 끝마치기를 기다리는 Thread#sleep을
사용하는 경우를 말한다.

#### 개선 방법
java.util.concurrent 패키지의 동기화 객체를 이용하면 테스트 스레드는 작업 스레드가 일을 끝마치는 즉시 알아챌 수 있다.

#### 정리
잠자는 달팽이란 다른 스레드가 완료되기를 기다리느라 Thread#sleep으로 긴 시간을 허비한 후에야 다음 단계를 진행하는, 아주 느릿느릿한 테스트를 말한다.

'테스트 스레드는 작업 스레드가 일을 마치는 즉시 알 수 있어야 한다'라는 생각에서 아이디어를 얻어, 자바 표준 API의 동기화 객체인
CountDownLatch를 이용해 해결 할 수 있다.

### 필셀 퍼펙션
픽셀 퍼펙션(Pixel perfection)은 기본 타입 단언과 매직 넘버의 특수한 형태다.

컴퓨터 그래픽스 분야에서 상당히 빈번하게 발견된다.

#### 개선 방법
대상을 적절히 추상화하여 표현한다.

테스트를 어렵게 만드는 세부 정보는 사용자 정의 단언으로 적절히 추상화해서 숨겨야 한다.(<b>기본 타입 단언</b>이 나설 자리가 아니다.)

#### 정리
사소한 값 비교에 집착하는 잘 부서지는 테스트보다 포괄적인 의미를 대조하는, 영리한 알고리즘을 이용하는 테스트를 하자.

### 파라미터화된 혼란
파라미터화된 테스트 패턴(Parameterized Test Pattern)은 데이터를 아주 조금씩만 바꿔가며 수차례 반복 검사하는 데이터 중심 테스트가 있을 때 중복을 없애주는 기법이다.

<b>파라미터화된 혼란</b>(Parameterized mess)는 파라미터화된 테스트를 과하게, 잘못된 상황에서 사용하면 코드도 이해하기 어렵고 실패한 테스트를 정확히 끄집어내기 어렵게 만든다.
- JUnit4와 관련하여 가장 많이 남용되는 기법

#### 개선 방법
- 여러 테스트 케이스를 하나의 테스트 메서드로 몰아넣는다.
- 테스트 데이터가 한눈에 들어오도록 구조를 변경한다.
- 개별 테스트 케이스의 식별자를 단언문의 실패 메시지에 추가한다.

#### 정리
Junit5의 @ParameterizedTest는 테스트 데이터가 한눈에 들어오고, 실패한 케이스를 파악하기 쉽다..

Junit4의 경우 개선방법을 적용해서 개선하면 된다.

### 메서드 간 응집력 결핍
응집력(cohesion)
- 클래스 하나는 <b>사물</b> 하나, 즉 하나의 추상화 개념을 표현한다는 뜻이다.

<b>메서드 간</b>
- 같은 클래스에 속한 메서드 간의 공통점이 많으냐를 기준으로 응집력의 강함을 정한다는 의미다.

한 클래스의 모든 테스트가 같은 <b>픽스처</b>를 이용해야 한다. 다른 픽스처를 이용하는 테스트 메서드는 독립된 테스트 클래스로 나눠야 한다.

#### 개선 방법
- 클래스를 분리한다.
- 모든 테스트 메서드가 같은 픽스처를 사용하게끔 강제한다.
- 적절한 경계를 찾아 클래스를 분리한다.

테스트 여러 개가 유틸리티 메서드를 공유하는 경우
- 유틸리티 메서드를 독립된 클래스로 옮겨서 새로 만든 테스트 클래스에도 함께 사용할 수 있도록 한다.
- 기반 클래스를 추출해서 유틸리티 기능을 모아놓고 나뉜 테스트 클래스에서 사용하도록 한다.

#### 정리
메서드가 응집력 결핍이란 테스 클래스 하나에 속한 테스트 메서드들이 서로 다른 픽스처 객체를 사용한다는 뜻이다.

모든 테스트가 같은 픽스처를 사용하도록 고쳐보고, 픽스처 자체도 관리하기 쉽도록 줄여가다 보면 문제가 사라질 것이다.

그럼에도 사라지지 않는다면 개선방법에 있는 방법을 적용하면 된다.

