## 6장

신뢰할 수 있는 코드를 만들기 위해서는 테스트 자체도 믿음직해야 한다.

### 주석으로 변한 테스트
<b>주석으로 변한 테스트</b>(Commented-out Test)는 테스트 코드가 주석으로 처리된 경우이다.

실행되지 않는 테스트 코드는 구현이 올바른지 검증하지도 못할뿐더러 설계 지침으로써의 역할도 전혀 수행하지 못하는 잡음에 불과하다.

#### 개선 방법
- 목적을 이해하려고 노력해보고 검증해본다. 성공했따면 주석을 풀고 파악한 몾겆ㄱ이 더 잘 표현되게끔 리팩토링 한다.
- 실패했다면 미련 없이 지워버린다.

#### 정리
주석으로 변한 테스트는 주석 처리한 <b>이유</b>를 찾기 위해 프로그래머의 아까운 시간을 좀먹게 하는 고약한 냄새다.

### 오해를 낳는 주석
<b>오해를 낳는 주석</b>(Misleading Comment)를 곧이곧대로 믿고 엉뚱한 곳에서 헤매는 프로그래머를 종종 볼 수 있다.

코드의 실제 동작과는 다른 주석을 오해를 낳는 주석이라고 한다.

#### 개선 방법
- 주석 대신 더 적절한 변수명이나 메서드명을 사용하라.
- 주석으로 설명하려던 코드 블록을 메서드로 추출하고 알맞은 이름을 지어줘라.

> 좋은 주석은 '무엇을'이 아닌 '왜'를 설명해주는 주석이다.

#### 정리
오해를 낳는 주석에 대처하기 위해서는 개선 방법을 통해 코드를 리팩토링 하면 된다.

좋은 주석이란 코드가 그렇게 작성될 수 밖에 없던 당위성을 설명하는 주석이다.

### 절대 실패하지 않는 테스트
<b>절대 실패하지 않는</b> 테스트(Never Failing Tests)는 사고가 나도 알려주지 않는다.

##### 개선 방법
예외라 발생하길 기대하는 테스트를 작성할 때 예외가 발생하지 않으면 fail()을 호출하게 한다.

Junit4을 이용할 때 @Test 애너테이션에 expected 속성을 사용한다.

#### 정리
테스트라면 실패해야 할 상황에서는 반드시 실패해야 한다. 만약 테스트가 실패하지 않으면 그릇된 안도감을 심어주므로 결코 가볍게 여겨서는 안 될 문제다.

### 지키지 못할 약속
테스트가 자신이 내세운 것보다 훨씬 적은 것을 검사하거나, 심지어 아무것도 검사하지 않는다는 게 
<b>지키지 못할 약속</b>(Shallow promises)의 본질적인 문제다.

지키지 못할 약속의 세 가지 경우
- 아무 '일'도 안하는 테스트
- 무언가 일은 하지만, 정작 '검증'은 전혀 하지 않는 테스트
- 이름값 못하는 테스트

#### 개선 방법
- 아무 일도 안하는 테스트
  - 메서드 본문 전체가 주석인 경우
  - 코드를 '지워버리는 게 주석 처리보다 낫다'
- 검증은 하지 않는 테스트
  - 단언문이 있는지 확인한다.
  - 테스트 작성시 단언문 부터 적으면 된다.
    - 검증 뿐만 아니라, 테스트로 확인하려는 정확한 동작이 무엇인가에 더 집중하게 해준다.
- 이름값 못하는 테스트
  - 테스트 작성시 단언문 부터 적으면 된다.
    - 테스트 이름과 단언문 둘만 있는 상태에서 둘이 서로 다르다는 걸 알아차리지 못할 리 없다.

### 낮아진 기대치
<b>낮아진 기대치</b>(Lowers expectations)는 검증 정확도와 정밀도를 낮춰버린다.

모호한 단언문으로 변화에 둔감한 테스트를 만들어서, 실패해야 할 상황에서도 실패하지 않는다.

#### 개선 방법
기준을 다시 높여서 예상한 바를 정확히 검사한다.

#### 정리
테스트는 자신이 명시한 동작에 문제가 생기면 실패해야 한다. 낮아진 기대치라는 테스트 냄새는 실패해야 할 상황에서도 실패하지 안흔ㄴ
지나치게 강건한 테스트를 만들어낸다.

지나치게 구체적인 단언문으 픽펠 퍼펙션(5장) 문제를 일으킬 위험이 있다.

### 플랫폼 편견 
<b>플랫폼 편견</b>(Platform Prejudice)이란 필요한 모든 플랫폼을 동등하게 다루지 못하는 테스트 냄새이다.

#### 개선 방법
플랫폼마다 다르게 동작하는 테스트를 지원 플랫폼의 수대로 나눠서 그 사실을 공개한다.
- 최소한 플랫폼 종속 코드가 있다는 사실 정도를 인지할 수 있다.

조건부로 실행되는 테스트(if/else)를 여러개로 나누고 Junit의 assumeTrue를 사용한다.
- IDE는 플랫폼별 테스트 일믕르 모두 나열하고 그 모두가 성공했다고 보고하는 문제가 있다.
- 이 냄새의 근원까지 제거하려면 코드를 리팩토링 해야할 수 있다.
  - 테스트를 간소화하여 테스트 각각이 자신에게 필요한 플랫폼을 직접 생성할 방법을 찾는것이 좋다.

### 조건부 테스트
<b>조건부 테스트</b>(Conditional tests)는 테스트 안에 숨겨진 조건 때문에 테스트의 이름이 의미하는 것과 다르게 동작하는 걸 말한다.

#### 개선 방법
테스트에서 조건문을 찾아내면 모든 갈래가 확실한 실패 조건을 가졌는지 확인하자.

각 분기마다 맡은바 검증을 정확히 수행하고 있는지도 살펴야 한다.

#### 정리
테스트 메서드의 모든 분기에는 자신만의 실패 조건이 있어야 한다. 하지만 엄밀히 말하면 테스트하려는 시나리오와 동작이 분기별로 서로 다르다는 뜻이니 각각을 독립된 테스트로 갈라놓는 것이 옳다.

불확실한 부분이 있다면 조건절보다는 가정 내용을 명시적으로 확인하는 단언문을 대신 사용하는걸 추천한다.